#!/usr/bin/env bash
usage="NAME
      install - install dotfiles project

SYNOPSIS
      install [-h] [-p|--core]

ARGUMENTS


       -f|--full)
          Do a full install. Including all AUR packages, not just required ones.
       -u|--user
          Name of your github account where dotfiles was forked to.
       -n|--new
          Indicate this is being run on a new install. This script needs to reset certain
          files during the initial setup. This flag allows it to do so.
"

while test $# -gt 0; do
	  case "$1" in
        -h|--help|-\?)
            echo "$usage" >&2
            exit;;
        -n|--new)
            _new=true;;
        -f|--full)
            full=true;;
        -u|--user)
            github_user=$2
            shift
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
        *)
            break
    esac
    shift
done

function check_required_params() {
    if [[ -z $github_user ]]; then
        echo "Github account name required" >&2
        exit 1
    fi
}

function update_pacman() {
    sudo pacman -Syu --noconfirm
    sudo pacman-optimize && sync
}

function install_pacman_packages() {
    common_pacman_packages=$(cat ~/.config/dotfiles/arch-packages/pacman)
    for package_name in $common_pacman_packages; do
        sudo pacman -S $package_name --needed --noconfirm --quiet
    done
}

#pacman-contrib:
#  used for 'checkupdates' command in polybar module that shows how many updates pacman has


# list of packages no longer used
# to be removed from system to avoid issues
remove_packages="
"

remove_aur_packages="
    ttf-font-awesome
    i3blocks-gaps-git
    rtv
"

# virtualbox-guest-modules-arch
virtualbox_packages="
    virtualbox-guest-utils
"

physical_packages="
"

function install_virtual_machine_needed_packages() {
    # install/update packages for virtualbox or physical install
    [[ "$(facter is_virtual)" == true ]] && \
        host_specific_pkgs=$virtualbox_packages || \
            host_specific_pkgs=$physical_packages
    echo 'installing host specific packages'
    for package_name in $host_specific_pkgs; do
        sudo pacman -S $package_name --needed --noconfirm
    done
}

function uninstall_deprecated_packages() {
    echo 'removing packages that are no longer needed'
    for package_name in $remove_packages; do
        sudo pacman -R --noconfirm $package_name
    done
    for package_name in $remove_aur_packages; do
        trizen -R --noconfirm package_name
    done

}
core_aur_packages="
    i3-gaps-next-git
    polybar-git
    paper-icon-theme-git
    awesome-terminal-fonts
    exa
    ccat
    xorg-xprop
    dunstify
    bashmount
    trizen
    mirage
    arc-gtk-theme-git
    awesome-terminal-fonts
"
function install_aur_packages() {
    ## RUST
    # some aur packages require compiling rust code
    # so this intializes rust
    rustup install stable
    rustup default stable
    ## END RUST
    for aur_package in $core_aur_packages; do
        trizen -S --needed $aur_package --noconfirm --noedit
    done
}

function install_extra_aur_packages() {
    if [[ $full = true ]]; then
        ## install aur packages
        aur_packages="
            hipchat
            spotify
            dropbox
            siji-git
            xorg-xset
            remmina-plugin-rdesktop
            pgadmin4
            cli-visualizer
            slack-desktop
            teams-for-linux
    "
        for aur_package in $aur_packages; do
            trizen -S --needed $aur_package --noconfirm --noedit
        done
    fi
}

function install_docker() {
    ## if the docker daemon isn't active, set it up
    systemctl -q is-active docker
    if [[ $? -ne 0 ]] ; then
        echo "Docker isn't running"
        ## refer to docker daemon documentation for further details:
        ## https://docs.docker.com/engine/installation/linux/linux-postinstall/
        ## create a group for docker
        sudo groupadd docker
        ## add current user to it so that you dont have to issue sudo everytime
        sudo usermod -aG docker $USER
        ## make sure the docker daemon starts on boot
        sudo systemctl enable docker
        ## start the docker daemon
        sudo systemctl start docker
        echo "Docker now running and set to run on boot. User added to group"
    fi
}

function install_oh-my-zsh_and_plugins() {
    ## Install oh-my-zsh
    sh /home/$USER/.local/bin/tools/install_oh_my_zsh
    yadm reset --hard origin/master
    # uses: https://github.com/lukechilds/zsh-nvm
    git clone https://github.com/lukechilds/zsh-nvm \
        ${ZSH_CUSTOM:-/home/$USER/.oh-my-zsh/custom}/plugins/zsh-nvm 2>/dev/null
    # nvm will globally install all packages listed in ~/.nvm/default-packages
    # TODO: this symlink needs to be made AFTER nvm is installed, which doesn't
    # happen until after .zshrc is sourced. Need to figure this out before enabling
    # this line
    # ln -s ~/.config/nvm/default-packges ~/.nvm/default-packages

    git clone https://github.com/zsh-users/zsh-autosuggestions \
        ${ZSH_CUSTOM:-/home/$USER/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 2>/dev/null
}

function install_node_packages() {
    # note: this function must be run after install_oh-my-zsh_and_plugins
    . /home/$USER/.nvm/nvm.sh ## source nvm
    node_version=$(<~/.nvmrc)
    nvm install $node_version
    npm i -g tern ## tern is used for the javascript layer in emacs
}


function install_python_packages() {
    ## Python package installs
    pip install --upgrade --user pip
    pip install --upgrade --user wakatime
    pip install --upgrade --user awscli
    pip install --upgrade --user polybar-reload
}


## Install Vundle
## commented out check for directory because it already exists. need to solve this problem another way.
#if [[ ! -d /home/han/.vim/bundle/Vundle.vim ]]; then
git clone https://github.com/VundleVim/Vundle.vim.git /home/$USER/.vim/bundle/Vundle.vim 2>/dev/null
#fi

mkdir -p $HOME/code

## Set yadm remote to .ssh
yadm remote set-url origin git@github.com:$github_user/dotfiles.git

## Install Spacemacs
if [[ ! -d ~/.emacs.d/.git ]]; then
  git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
fi

## Commenting this out.. not sure if it is needed 2/4/18
## use vmware setupscript (works with virtualbox)
# if [[ ! -d ~/Downloads/vmware-tools/.git ]]; then
#   git clone https://github.com/rasa/vmware-tools-patches.git ~/Downloads/vmware-tools/
#   sudo sh /home/han/Downloads/vmware-tools/patched-open-vm-tools.sh
# fi


# TODO: create function the installs code
# code=( "nodejs" "rust" "golang" "awscli" "azcli" )
# function install_code() {
#     for c in $code; do
#         echo c
#     done
# }



# TODO: add golang setup back in
function install_golang() {

    # needed for spacemacs go layer
    # https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/go
    go get -u -v github.com/nsf/gocode
    go get -u -v github.com/rogpeppe/godef
    go get -u -v golang.org/x/tools/cmd/guru
    go get -u -v golang.org/x/tools/cmd/gorename
    go get -u -v golang.org/x/tools/cmd/goimports
}
# gopath isn't set, so this trys to make a dir in /src which
# gives permission denied. subsequent calls to the script succeed beacuse .zshrc is sourced and gopath is set there.
# mkdir -p $GOPATH/src/github.com
# go get -u -v github.com/nsf/gocode
# go get -u -v github.com/rogpeppe/godef
# go get -u -v golang.org/x/tools/cmd/guru
# go get -u -v golang.org/x/tools/cmd/gorename
# go get -u -v golang.org/x/tools/cmd/goimports


function main() {
    check_required_params
    update_pacman
    install_pacman_packages
    install_aur_packages
    install_extra_aur_packages
    install_docker
    install_node_packages
    install_python_packages
    uninstall_deprecated_packages

    if [[ _new == true ]]; then
        install_oh-my-zsh_and_plugins
        reboot
    fi
}

main
